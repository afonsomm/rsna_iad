# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/1_dicom_to_nifti.ipynb.

# %% auto 0
__all__ = ['dicom_serie_load', 'dicom_get_zposition', 'dicom_get_rescale_factors', 'dicom_split_array_from_metadata',
           'dicom_serie_process', 'dicom_get_spacing', 'dicom_serie_get_spacing', 'dicom_volume_to_nifti',
           'dicom_serie_to_nifti', 'dicom_series_to_niftis']

# %% ../nbs/1_dicom_to_nifti.ipynb 4
import os
import pydicom

def dicom_serie_load(series_base_path, serie_uid):

    serie_path = f"{series_base_path}/{serie_uid}"
    instances_filename = os.listdir(serie_path)
    n_instances = len(instances_filename)

    ds_l = [None] * n_instances
    for i, instance_filename in enumerate(instances_filename):
        ds_l[i] = pydicom.dcmread(f"{serie_path}/{instance_filename}")

    return ds_l

# %% ../nbs/1_dicom_to_nifti.ipynb 7
def dicom_get_zposition(ds):
    
    if getattr(ds, "ImagePositionPatient", None) and len(ds.ImagePositionPatient) >= 3:
        z_position = ds.ImagePositionPatient[2]
    else:  # in case the tag is missing or does not contain the z axis position
        z_position = ds.InstanceNumber

    return float(z_position)

# %% ../nbs/1_dicom_to_nifti.ipynb 11
def dicom_get_rescale_factors(ds):

    slope = getattr(ds, "RescaleSlope", 1.0)
    intercept = getattr(ds, "RescaleIntercept", 0.0)
    
    return float(slope), float(intercept)

# %% ../nbs/1_dicom_to_nifti.ipynb 15
import torch
from copy import deepcopy

def dicom_split_array_from_metadata(ds):  # process a single DICOM

    ds_copy = deepcopy(ds)  # copy the dicom object
    pixel_pt = torch.from_numpy(ds_copy.pixel_array)
    del ds_copy.PixelData  # remove pixel data from the dicom object copy
    
    return pixel_pt, ds_copy

# %% ../nbs/1_dicom_to_nifti.ipynb 18
def dicom_serie_process(ds_l):

    n_ds = len(ds_l)

    pixel_pt, ds_metadata = dicom_split_array_from_metadata(ds_l[0])  # Get first instance

    if n_ds == 1:  # one dicom with the whole volume
        volume = pixel_pt
        ds_metadata_l = [ds_metadata]
    else:  # each dicom with a slice
        volume = torch.zeros((n_ds, *pixel_pt.shape), dtype=torch.float32)
        ds_metadata_l = [None] * n_ds
        volume[0] = pixel_pt
        ds_metadata_l[0] = ds_metadata

        # To later sort the slices
        zpositions = torch.zeros((n_ds,), dtype=torch.float32)
        zpositions[0] = dicom_get_zposition(ds_l[0])
        
        for i, ds in enumerate(ds_l[1:], start=1):
            volume[i], ds_metadata_l[i] = dicom_split_array_from_metadata(ds)
            zpositions[i] = dicom_get_zposition(ds)

		# sort slices in the volume
        zpositions_argsort = torch.argsort(zpositions)
        volume = volume[zpositions_argsort]
	
    # rescale volume
    slope, intercept = dicom_get_rescale_factors(ds_l[0])
    volume = volume * slope + intercept
    
    return volume, ds_metadata_l

# %% ../nbs/1_dicom_to_nifti.ipynb 21
def dicom_get_spacing(ds):

    pixel_spacing = getattr(ds, "PixelSpacing", None)
    slice_thickness = getattr(ds, "SliceThickness", None)

    if (pixel_spacing is None) or (slice_thickness is None):
        shared_functional_groups_sequence = getattr(ds, "SharedFunctionalGroupsSequence", None)
        if shared_functional_groups_sequence is not None:
            pixel_measures_sequence = getattr(shared_functional_groups_sequence[0], "PixelMeasuresSequence", None)
            if pixel_measures_sequence is not None:
                if pixel_spacing is None:
                    pixel_spacing = getattr(pixel_measures_sequence[0], "PixelSpacing", None)
                if slice_thickness is None:
                    slice_thickness = getattr(pixel_measures_sequence[0], "SliceThickness", None)
    
    if pixel_spacing is None or slice_thickness is None:
        raise Exception("Missing either Pixel Spacing or Slice Thickness.")
    
    pixel_spacing = [float(axis_spacing) for axis_spacing in pixel_spacing]
    slice_thickness = float(slice_thickness)
    spacing = [*pixel_spacing, slice_thickness]

    return spacing

# %% ../nbs/1_dicom_to_nifti.ipynb 23
def dicom_serie_get_spacing(ds_l):

    spacings = torch.zeros((len(ds_l), 3), requires_grad=False)
    for i, ds in enumerate(ds_l):
        spacings[i] = torch.tensor(dicom_get_spacing(ds))

    return spacings.mode(dim=0).values

# %% ../nbs/1_dicom_to_nifti.ipynb 26
import numpy as np
import nibabel

def dicom_volume_to_nifti(volume, ds_metadata_l, serie_uid, path):

    nifti_path = f"{path}/{serie_uid}.nii.gz"

    nifti = nibabel.nifti1.Nifti1Image(volume.detach().cpu().numpy(), affine=np.eye(4))
    spacing = dicom_serie_get_spacing(ds_metadata_l)    
    nifti.header.set_zooms(spacing)
    
    nibabel.save(nifti, nifti_path)

# %% ../nbs/1_dicom_to_nifti.ipynb 28
def dicom_serie_to_nifti(base_path_dicom, serie_uid, base_path_nifti):
    ds_l = dicom_serie_load(base_path_dicom, serie_uid)
    volume, ds_metadata_l = dicom_serie_process(ds_l)
    dicom_volume_to_nifti(volume, ds_metadata_l,  serie_uid, base_path_nifti)

# %% ../nbs/1_dicom_to_nifti.ipynb 31
from concurrent.futures import ProcessPoolExecutor, as_completed
import multiprocessing
from tqdm import tqdm

def dicom_series_to_niftis(base_path_dicoms, series_uid, base_path_niftis, max_workers):

    with ProcessPoolExecutor(max_workers=max_workers) as executor:
        futures = [executor.submit(dicom_serie_to_nifti, base_path_dicoms, serie_uid, base_path_niftis) for serie_uid in series_uid]
        for future in tqdm(as_completed(futures), total=len(futures)):
            ...
